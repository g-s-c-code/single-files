<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeGems</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/vs2015.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <style>
        body, button { font-family: monospace; color: white; border: none; }
        h2 { white-space: nowrap; }
        .code-container { margin: 1rem 2rem 3rem 2rem; position: relative; }
        .code-container h4, h6, button { display: inline-flex; background-color: transparent; }
        .code-container pre { border: 2px solid; border-radius: 5px; overflow: auto; }
    </style>
</head>

<body class="bg-dark p-0">
    <nav class="navbar navbar-dark sticky-top bg-dark p-0 ps-2 border-bottom">
        <h1>CodeGems<i class="fs-6"> </i><i class="fs-2 bi-journal-code"></i></h1>
        <button class="btn" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ps-2">
                <li class="nav-item">
                    <a class="nav-link" href="#section1">HTML</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#section2">Sorting Algorithms</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#section3">Generic Methods</a>
                </li>
            </ul>
        </div>
    </nav>


    <div class="container m-4" id="section1">
        <h2>HTML</h2>
    </div>

    <!--Basic HTML Skeleton with Bootstrap CDNs-->
    <div class="code-container">
        <h4>Template w. Bootstrap CDNs</h4>
        <pre><code>
    &lt;!DOCTYPE html&gt;
    &lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;Document Title&lt;/title&gt;
        &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"&gt;
        &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css"&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;!-- Content --&gt;

        &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
        </code></pre>
        <p>This skeleton includes necessary metadata and Bootstrap's CSS/JS CDNs.</p>
        <p><h6>Use case:</h6> Copy and paste to quicky start a responsive and stylized web application or site without manually setting up Bootstrap.</p>
    </div>
    <!--/Basic HTML Skeleton with Bootstrap CDNs-->


    <div class="container m-4" id="section2">
        <h2>Sorting Algorithms</h2>
        <p>In computer science, the efficiency of algorithms is gauged by observing the growth of their resource requirements as the input size escalates. This is expressed using the "big O" notation, which sets an upper limit on an algorithm's growth rate, be it in terms of runtime or space.</p>

        <h5>Asymptotic Analysis</h5>
        <p>This examines how an algorithm's efficiency evolves as the input size approaches infinity. We typically focus on larger data sets because while most algorithms handle small data promptly, larger sets pose challenges.</p>

        <h5>Big O Notation</h5>
        <p>Big O is a standard notation that signifies the maximum growth of an algorithm's runtime. It projects the worst-case scenario for an algorithm's growth rate as input size increases.</p>
        <ul>
            <li><strong>O(1)</strong> (Constant Time): The algorithm's time remains unchanged regardless of input size. e.g., accessing an array element via its index.</li>
            <li><strong>O(log n)</strong> (Logarithmic Time): The input size is considerably reduced at every algorithm step, like in binary search.</li>
            <li><strong>O(n)</strong> (Linear Time): The runtime is proportional to input size. Common in simple search algorithms.</li>
            <li><strong>O(n log n)</strong>: Balances between linear and quadratic complexities. Seen in efficient sorts like mergesort.</li>
            <li><strong>O(n^2), O(n^3)</strong> (Polynomial Time): The runtime grows polynomially. E.g., bubble sort for O(n^2).</li>
            <li><strong>O(2^n)</strong> (Exponential Time): These have exponential growth rates, making them impractical for even modest inputs. Found in some recursive algorithms.</li>
            <li><strong>O(n!)</strong> (Factorial Time): Extremely fast growth, seen in algorithms that generate all set permutations.</li>
        </ul>

        <h5>Other Notations</h5>
        <ul>
            <li><strong>Big Ω (Omega Notation)</strong>: Denotes the minimum runtime of an algorithm.</li>
            <li><strong>Big Θ (Theta Notation)</strong>: Represents both the upper and lower limits on runtime.</li>
        </ul>

        <h5>Analyzing Algorithms</h5>
        <p>To deduce the Big O of an algorithm:</p>
        <ol>
            <li>Pinpoint the input size (n) which varies based on data structure.</li>
            <li>Spot the recurring operations as n expands. Loops are frequent offenders.</li>
            <li>Count the repetitions of these operations. This initial count in relation to n gives a basic idea of time complexity.</li>
            <li>Represent the growth using Big O, usually simplifying by dropping constants and lesser terms. E.g., from 3n^2 + 2n + 4 to O(n^2).</li>
        </ol>
        <p>Note: Big O focuses on growth rates, sidelining specifics. For smaller inputs, a faster yet less efficient algorithm might beat a slower but more efficient one. However, with larger inputs, the latter usually prevails.</p>
    
        <h2 class="mt-5">C# - Sorting Algorithms</h2>
    </div>

    <!--MergeSort-->
    <div class="code-container">
        <h4>MergeSort</h4>
        <pre><code class="csharp">
    using System;

    public class MergeSorter
    {
        public static void MergeSort(int[] arr, int left, int right)
        {
            if (left < right)
            {
                int mid = (left + right) / 2;

                MergeSort(arr, left, mid);      // Recursively sort first half
                MergeSort(arr, mid + 1, right); // Recursively sort second half

                Merge(arr, left, mid, right);   // Merge the sorted halves
            }
        }

        // Function to merge two subarrays into one sorted array
        private static void Merge(int[] arr, int left, int mid, int right)
        {
            int n1 = mid - left + 1;
            int n2 = right - mid;

            int[] L = new int[n1];
            int[] R = new int[n2];

            Array.Copy(arr, left, L, 0, n1);
            Array.Copy(arr, mid + 1, R, 0, n2);

            int i = 0, j = 0;
            for (int k = left; k <= right; k++)
            {
                if (i < n1 && (j >= n2 || L[i] <= R[j]))
                {
                    arr[k] = L[i];
                    i++;
                }
                else
                {
                    arr[k] = R[j];
                    j++;
                }
            }
        }
    }
        </code></pre>
        <p>A "divide-and-conquer" algorithm that divides the unsorted list into n sublists, each containing one element, and then repeatedly merges sublists to produce new sorted sublists until there's only one sublist remaining.</p>
        <p><h6>Use case:</h6> Large datasets and linked lists.</p>
        <div class="performance-complexities">
            <h6>Performance Complexities:</h6>
            <ul>
                <li><strong>Worst-case:</strong> O(n log n)</li>
                <li><strong>Average-case:</strong> O(n log n)</li>
                <li><strong>Best-case:</strong> O(n log n)</li>
            </ul>
        </div>
    </div>
    <!--/MergeSort-->
    
    <!--QuickSort-->
    <div class="code-container">
        <h4>QuickSort</h4>
        <pre><code class="csharp">
    using System;

    public class QuickSorter
    {
        // Main QuickSort function
        public static void QuickSort(int[] arr, int low, int high)
        {
            if (low < high)
            {
                int pi = Partition(arr, low, high);

                QuickSort(arr, low, pi - 1);  // Recursively sort elements before pivot
                QuickSort(arr, pi + 1, high); // Recursively sort elements after pivot
            }
        }

        // Function to partition the array
        private static int Partition(int[] arr, int low, int high)
        {
            // Median-of-three pivot selection
            int mid = low + (high - low) / 2;
            if (arr[mid] < arr[low]) Swap(ref arr[mid], ref arr[low]);
            if (arr[high] < arr[low]) Swap(ref arr[high], ref arr[low]);
            if (arr[mid] < arr[high]) Swap(ref arr[mid], ref arr[high]);

            int pivot = arr[high];   // Pivot is now the last element
            int i = (low - 1);

            for (int j = low; j <= high - 1; j++)
            {
                if (arr[j] < pivot)
                {
                    i++;
                    Swap(ref arr[i], ref arr[j]);
                }
            }
            Swap(ref arr[i + 1], ref arr[high]);
            return (i + 1);
        }

        // Utility function to swap two elements
        private static void Swap(ref int a, ref int b)
        {
            int temp = a;
            a = b;
            b = temp;
        }
    }
        </code></pre>
        <p>It works by selecting a 'pivot' element and partitioning the array such that all elements smaller than the pivot come before, and all larger elements come after. This partitioning is then applied recursively to the two sub-arrays.</p>
        <p><h6>Use case:</h6> Large datasets, but its worst-case performance can be poor.</p>
        <div class="performance-complexities">
            <h6>Performance Complexities:</h6>
            <ul>
                <li><strong>Worst-case:</strong> O(n^2)</li>
                <li><strong>Average-case:</strong> O(n log n)</li>
                <li><strong>Best-case:</strong> O(n log n)</li>
            </ul>
        </div>
    </div>
    <!--/QuickSort-->

    <!--HeapSort-->
    <div class="code-container">
        <h4>HeapSort</h4>
        <pre><code class="csharp">
    using System;

    public class HeapSorter
    {
        // Main HeapSort function
        public static void HeapSort(int[] arr)
        {
            int n = arr.Length;

            // Build a max heap from the array
            for (int i = n / 2 - 1; i >= 0; i--)
                Heapify(arr, n, i);

            // Extract elements from heap one by one
            for (int i = n - 1; i > 0; i--)
            {
                Swap(ref arr[0], ref arr[i]);
                Heapify(arr, i, 0);
            }
        }

        // Rearranges array to satisfy heap property
        private static void Heapify(int[] arr, int n, int i)
        {
            int largest = i;
            int left = 2 * i + 1;
            int right = 2 * i + 2;

            if (left < n && arr[left] > arr[largest])
                largest = left;
            if (right < n && arr[right] > arr[largest])
                largest = right;

            if (largest != i)
            {
                Swap(ref arr[i], ref arr[largest]);
                Heapify(arr, n, largest);
            }
        }

        // Utility function to swap two elements in the array
        private static void Swap(ref int a, ref int b)
        {
            int temp = a;
            a = b;
            b = temp;
        }
    }
        </code></pre>
        <p>It works by visualizing the elements of the array as a special kind of binary tree called a heap. The algorithm then uses the properties of heaps to efficiently build a sorted array.</p>
        <p><h6>Use case:</h6> Situations where computational predictability is needed, as it always performs O(n log n) operations.</p>
        <div class="performance-complexities">
            <h6>Performance Complexities:</h6>
            <ul>
                <li><strong>Worst-case:</strong> O(n log n)</li>
                <li><strong>Average-case:</strong> O(n log n)</li>
                <li><strong>Best-case:</strong> O(n log n)</li>
            </ul>
        </div>
    </div>
    <!--/HeapSort-->

    <!--RadixSort-->
    <div class="code-container">
        <h4>RadixSort</h4>
        <pre><code class="csharp">
    using System;
    using System.Linq;

    public class RadixSorter
    {
        // Main RadixSort function
        public static void RadixSort(int[] arr)
        {
            int max = arr.Max();

            // Process every digit position
            for (int exp = 1; max / exp > 0; exp *= 10)
                CountSortForRadix(arr, arr.Length, exp);
        }

        // A counting sort algorithm used to sort the array based on significant digits
        private static void CountSortForRadix(int[] arr, int n, int exp)
        {
            int[] output = new int[n];
            int[] count = new int[10];

            // Store the count of occurrences in count[]
            for (int i = 0; i < n; i++)
                count[(arr[i] / exp) % 10]++;

            // Change count[i] so that count[i] contains the actual 
            // position of this digit in output[]
            for (int i = 1; i < 10; i++)
                count[i] += count[i - 1];

            // Build the output array
            for (int i = n - 1; i >= 0; i--)
            {
                output[count[(arr[i] / exp) % 10] - 1] = arr[i];
                count[(arr[i] / exp) % 10]--;
            }

            // Copy the sorted values to original array
            for (int i = 0; i < n; i++)
                arr[i] = output[i];
        }
    }
        </code></pre>
        <p>It's a non-comparative sorting algorithm that works by distributing elements of an array into buckets according to their individual digits. After all digits have been processed, the result will be a sorted list.</p>
        <p><h6>Use case:</h6> Sorting large numbers or strings.</p>
        <div class="performance-complexities">
            <h6>Performance Complexities:</h6>
            <ul>
                <li><strong>Worst-case:</strong> O(nk) (where k is the number of digits/characters of the longest number/string)</li>
                <li><strong>Average-case:</strong> O(nk)</li>
                <li><strong>Best-case:</strong> O(nk)</li>
            </ul>
        </div>
    </div>
    <!--/RadixSort-->

    <!--CountingSort-->
    <div class="code-container">
        <h4>CountingSort</h4>
        <pre><code class="csharp">
    using System;
    using System.Linq;

    public class CountingSorter
    {
        public static void CountingSort(int[] arr)
        {
            // Find the maximum value to know the range
            int max = arr.Max();

            // Initialize the count and output arrays
            int[] count = new int[max + 1];
            int[] output = new int[arr.Length];

            // Store the count of each element
            for (int i = 0; i < arr.Length; i++)
                count[arr[i]]++;

            // Update count[i] to store the actual position 
            // of this digit in output[]
            for (int i = 1; i <= max; i++)
                count[i] += count[i - 1];

            // Build the output array
            for (int i = arr.Length - 1; i >= 0; i--)
            {
                output[count[arr[i]] - 1] = arr[i];
                count[arr[i]]--;
            }

            // Copy the sorted values to the original array
            for (int i = 0; i < arr.Length; i++)
                arr[i] = output[i];
        }
    }
        </code></pre>
        <p>It operates by counting the number of objects that have each distinct key value and using arithmetic to determine the position of each key in the output sequence. It's efficient when the range of input values is limited.</p>
        <p><h6>Use case:</h6> Small integer keys.</p>
        <div class="performance-complexities">
            <h6>Performance Complexities:</h6>
            <ul>
                <li><strong>Worst-case:</strong> O(n + k) (where k is the range of the input)</li>
                <li><strong>Average-case:</strong> O(n + k)</li>
                <li><strong>Best-case:</strong> O(n + k)</li>
            </ul>
        </div>
    </div>
    
    <!--/CountingSort-->

    <!--BucketSort-->
    <div class="code-container">
        <h4>BucketSort</h4>
        <pre><code class="csharp">
    using System;
    using System.Collections.Generic;

    public class BucketSorter
    {
        public static void BucketSort(float[] arr)
        {
            int n = arr.Length;

            // Create 'n' empty buckets
            List<float>[] buckets = new List<float>[n];
            for (int i = 0; i < n; i++)
                buckets[i] = new List<float>();

            // Place array elements in different buckets
            for (int i = 0; i < n; i++)
            {
                int bucketIndex = (int)(n * arr[i]);
                buckets[bucketIndex].Add(arr[i]);
            }

            // Sort individual buckets
            for (int i = 0; i < n; i++)
                buckets[i].Sort();

            // Concatenate all sorted buckets into arr
            int index = 0;
            for (int i = 0; i < n; i++)
                for (int j = 0; j < buckets[i].Count; j++)
                    arr[index++] = buckets[i][j];
        }
    }
        </code></pre>
        <p>It distributes the elements of an array into several buckets. Each bucket is then sorted individually, either using a different sorting algorithm or recursively applying the bucket sort.</p>
        <p><h6>Use case:</h6> Data that is uniformly distributed over a range.</p>
        <div class="performance-complexities">
            <h6>Performance Complexities:</h6>
            <ul>
                <li><strong>Worst-case:</strong> O(n^2) (when all elements end up in one bucket)</li>
                <li><strong>Average-case:</strong> O(n + n^2/k + k) (where k is the number of buckets)</li>
                <li><strong>Best-case:</strong> O(n + k) (when each bucket has just one element)</li>
            </ul>
        </div>
    </div>
    <!--/BucketSort-->


    <div class="container m-4" id="section3">
        <h2>C# - Generic Methods</h2>
    </div>

    <!--Placeholder-->
    <div class="code-container">
        <h4>BucketSort</h4>
        <pre><code class="csharp">
    static void Example(Placeholder[] arr)
    {
        
    }
        </code></pre>
        <p>Comment</p>
        <p><h6>Use case:</h6> Explenation</p>
    </div>
    <!--/Placeholder-->

    <script>
        //Clipboard Function
        function copy(button) {
        const container = button.closest(".code-container");
        const text = container.querySelector('code').innerText;
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('Copied to clipboard.');
        }

        //Add Clipboard To Every Code Container
        document.addEventListener("DOMContentLoaded", function() {
        const containers = document.querySelectorAll(".code-container");
        containers.forEach(container => {
        const button = document.createElement("button");
        button.classList.add("bi-clipboard");
        button.onclick = function() { copy(this); };
        container.insertBefore(button, container.children[1]);
        });
        });

        //Collapse Navbar After Item Is Clicked
        document.addEventListener('DOMContentLoaded', (event) => {
        const navbarLinks = document.querySelectorAll('.navbar-nav .nav-link');
        const navbarCollapse = document.getElementById('navbarNav');
        navbarLinks.forEach(link => {
        link.addEventListener('click', (e) => {
        let bsCollapse = new bootstrap.Collapse(navbarCollapse, {
        toggle: false
        });
        bsCollapse.hide();
        setTimeout(() => {
        window.location.href = e.target.href;
        }, 350);
        });
        });
        });

    </script>

    <!-- CDNs -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/csharp.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
